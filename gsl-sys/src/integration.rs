/* automatically generated by rust-bindgen */

extern "C" {
    pub fn gsl_log1p(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_expm1(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_hypot(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn gsl_hypot3(x: f64, y: f64, z: f64) -> f64;
}
extern "C" {
    pub fn gsl_acosh(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_asinh(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_atanh(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_isnan(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_isinf(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_finite(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_nan() -> f64;
}
extern "C" {
    pub fn gsl_posinf() -> f64;
}
extern "C" {
    pub fn gsl_neginf() -> f64;
}
extern "C" {
    pub fn gsl_fdiv(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn gsl_coerce_double(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_coerce_float(x: f32) -> f32;
}
extern "C" {
    pub fn gsl_coerce_long_double(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_ldexp(x: f64, e: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn gsl_frexp(x: f64, e: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn gsl_fcmp(x1: f64, x2: f64, epsilon: f64) -> ::std::os::raw::c_int;
}
pub type gsl_prec_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn gsl_pow_2(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_3(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_4(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_5(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_6(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_7(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_8(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_9(x: f64) -> f64;
}
extern "C" {
    pub fn gsl_pow_int(x: f64, n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn gsl_pow_uint(x: f64, n: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    pub fn gsl_max(a: f64, b: f64) -> f64;
}
extern "C" {
    pub fn gsl_min(a: f64, b: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_function_struct {
    pub function: ::std::option::Option<unsafe extern "C" fn(x: f64,
                                                             params:
                                                                 *mut ::std::os::raw::c_void)
                                            -> f64>,
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gsl_function_struct() {
    assert_eq!(::std::mem::size_of::<gsl_function_struct>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( gsl_function_struct ) ));
    assert_eq! (::std::mem::align_of::<gsl_function_struct>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gsl_function_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_struct ) ) . function as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_struct ) ,
                "::" , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_struct ) ) . params as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_struct ) ,
                "::" , stringify ! ( params ) ));
}
impl Clone for gsl_function_struct {
    fn clone(&self) -> Self { *self }
}
pub type gsl_function = gsl_function_struct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_function_fdf_struct {
    pub f: ::std::option::Option<unsafe extern "C" fn(x: f64,
                                                      params:
                                                          *mut ::std::os::raw::c_void)
                                     -> f64>,
    pub df: ::std::option::Option<unsafe extern "C" fn(x: f64,
                                                       params:
                                                           *mut ::std::os::raw::c_void)
                                      -> f64>,
    pub fdf: ::std::option::Option<unsafe extern "C" fn(x: f64,
                                                        params:
                                                            *mut ::std::os::raw::c_void,
                                                        f: *mut f64,
                                                        df: *mut f64)>,
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gsl_function_fdf_struct() {
    assert_eq!(::std::mem::size_of::<gsl_function_fdf_struct>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( gsl_function_fdf_struct ) ));
    assert_eq! (::std::mem::align_of::<gsl_function_fdf_struct>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gsl_function_fdf_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_fdf_struct ) ) . f as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_fdf_struct
                ) , "::" , stringify ! ( f ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_fdf_struct ) ) . df as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_fdf_struct
                ) , "::" , stringify ! ( df ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_fdf_struct ) ) . fdf as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_fdf_struct
                ) , "::" , stringify ! ( fdf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_fdf_struct ) ) . params as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_fdf_struct
                ) , "::" , stringify ! ( params ) ));
}
impl Clone for gsl_function_fdf_struct {
    fn clone(&self) -> Self { *self }
}
pub type gsl_function_fdf = gsl_function_fdf_struct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_function_vec_struct {
    pub function: ::std::option::Option<unsafe extern "C" fn(x: f64,
                                                             y: *mut f64,
                                                             params:
                                                                 *mut ::std::os::raw::c_void)
                                            -> ::std::os::raw::c_int>,
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_gsl_function_vec_struct() {
    assert_eq!(::std::mem::size_of::<gsl_function_vec_struct>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( gsl_function_vec_struct ) ));
    assert_eq! (::std::mem::align_of::<gsl_function_vec_struct>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gsl_function_vec_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_vec_struct ) ) . function as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_vec_struct
                ) , "::" , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_function_vec_struct ) ) . params as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gsl_function_vec_struct
                ) , "::" , stringify ! ( params ) ));
}
impl Clone for gsl_function_vec_struct {
    fn clone(&self) -> Self { *self }
}
pub type gsl_function_vec = gsl_function_vec_struct;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_integration_workspace {
    pub limit: usize,
    pub size: usize,
    pub nrmax: usize,
    pub i: usize,
    pub maximum_level: usize,
    pub alist: *mut f64,
    pub blist: *mut f64,
    pub rlist: *mut f64,
    pub elist: *mut f64,
    pub order: *mut usize,
    pub level: *mut usize,
}
#[test]
fn bindgen_test_layout_gsl_integration_workspace() {
    assert_eq!(::std::mem::size_of::<gsl_integration_workspace>() , 88usize ,
               concat ! (
               "Size of: " , stringify ! ( gsl_integration_workspace ) ));
    assert_eq! (::std::mem::align_of::<gsl_integration_workspace>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gsl_integration_workspace )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . limit as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . nrmax as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( nrmax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . i as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) .
                maximum_level as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! (
                maximum_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . alist as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( alist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . blist as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( blist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . rlist as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( rlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . elist as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( elist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . order as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_workspace ) ) . level as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_workspace ) , "::" , stringify ! ( level ) ));
}
impl Clone for gsl_integration_workspace {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gsl_integration_workspace_alloc(n: usize)
     -> *mut gsl_integration_workspace;
}
extern "C" {
    pub fn gsl_integration_workspace_free(w: *mut gsl_integration_workspace);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_integration_qaws_table {
    pub alpha: f64,
    pub beta: f64,
    pub mu: ::std::os::raw::c_int,
    pub nu: ::std::os::raw::c_int,
    pub ri: [f64; 25usize],
    pub rj: [f64; 25usize],
    pub rg: [f64; 25usize],
    pub rh: [f64; 25usize],
}
#[test]
fn bindgen_test_layout_gsl_integration_qaws_table() {
    assert_eq!(::std::mem::size_of::<gsl_integration_qaws_table>() , 824usize
               , concat ! (
               "Size of: " , stringify ! ( gsl_integration_qaws_table ) ));
    assert_eq! (::std::mem::align_of::<gsl_integration_qaws_table>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( gsl_integration_qaws_table )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . alpha as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( alpha )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . beta as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( beta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . mu as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( mu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . nu as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( nu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . ri as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( ri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . rj as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( rj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . rg as *
                const _ as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( rg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qaws_table ) ) . rh as *
                const _ as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qaws_table ) , "::" , stringify ! ( rh ) ));
}
impl Clone for gsl_integration_qaws_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gsl_integration_qaws_table_alloc(alpha: f64, beta: f64,
                                            mu: ::std::os::raw::c_int,
                                            nu: ::std::os::raw::c_int)
     -> *mut gsl_integration_qaws_table;
}
extern "C" {
    pub fn gsl_integration_qaws_table_set(t: *mut gsl_integration_qaws_table,
                                          alpha: f64, beta: f64,
                                          mu: ::std::os::raw::c_int,
                                          nu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qaws_table_free(t:
                                               *mut gsl_integration_qaws_table);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum gsl_integration_qawo_enum {
    GSL_INTEG_COSINE = 0,
    GSL_INTEG_SINE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_integration_qawo_table {
    pub n: usize,
    pub omega: f64,
    pub L: f64,
    pub par: f64,
    pub sine: gsl_integration_qawo_enum,
    pub chebmo: *mut f64,
}
#[test]
fn bindgen_test_layout_gsl_integration_qawo_table() {
    assert_eq!(::std::mem::size_of::<gsl_integration_qawo_table>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( gsl_integration_qawo_table ) ));
    assert_eq! (::std::mem::align_of::<gsl_integration_qawo_table>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( gsl_integration_qawo_table )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . n as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . omega as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( omega )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . L as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( L ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . par as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( par ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . sine as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( sine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_qawo_table ) ) . chebmo
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_qawo_table ) , "::" , stringify ! ( chebmo )
                ));
}
impl Clone for gsl_integration_qawo_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gsl_integration_qawo_table_alloc(omega: f64, L: f64,
                                            sine: gsl_integration_qawo_enum,
                                            n: usize)
     -> *mut gsl_integration_qawo_table;
}
extern "C" {
    pub fn gsl_integration_qawo_table_set(t: *mut gsl_integration_qawo_table,
                                          omega: f64, L: f64,
                                          sine: gsl_integration_qawo_enum)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qawo_table_set_length(t:
                                                     *mut gsl_integration_qawo_table,
                                                 L: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qawo_table_free(t:
                                               *mut gsl_integration_qawo_table);
}
pub type gsl_integration_rule =
    ::std::option::Option<unsafe extern "C" fn(f: *const gsl_function, a: f64,
                                               b: f64, result: *mut f64,
                                               abserr: *mut f64,
                                               defabs: *mut f64,
                                               resabs: *mut f64)>;
extern "C" {
    pub fn gsl_integration_qk15(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk21(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk31(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk41(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk51(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk61(f: *const gsl_function, a: f64, b: f64,
                                result: *mut f64, abserr: *mut f64,
                                resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qcheb(f: *mut gsl_function, a: f64, b: f64,
                                 cheb12: *mut f64, cheb24: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qk(n: ::std::os::raw::c_int, xgk: *const f64,
                              wg: *const f64, wgk: *const f64, fv1: *mut f64,
                              fv2: *mut f64, f: *const gsl_function, a: f64,
                              b: f64, result: *mut f64, abserr: *mut f64,
                              resabs: *mut f64, resasc: *mut f64);
}
extern "C" {
    pub fn gsl_integration_qng(f: *const gsl_function, a: f64, b: f64,
                               epsabs: f64, epsrel: f64, result: *mut f64,
                               abserr: *mut f64, neval: *mut usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qag(f: *const gsl_function, a: f64, b: f64,
                               epsabs: f64, epsrel: f64, limit: usize,
                               key: ::std::os::raw::c_int,
                               workspace: *mut gsl_integration_workspace,
                               result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qagi(f: *mut gsl_function, epsabs: f64,
                                epsrel: f64, limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qagiu(f: *mut gsl_function, a: f64, epsabs: f64,
                                 epsrel: f64, limit: usize,
                                 workspace: *mut gsl_integration_workspace,
                                 result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qagil(f: *mut gsl_function, b: f64, epsabs: f64,
                                 epsrel: f64, limit: usize,
                                 workspace: *mut gsl_integration_workspace,
                                 result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qags(f: *const gsl_function, a: f64, b: f64,
                                epsabs: f64, epsrel: f64, limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qagp(f: *const gsl_function, pts: *mut f64,
                                npts: usize, epsabs: f64, epsrel: f64,
                                limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qawc(f: *mut gsl_function, a: f64, b: f64, c: f64,
                                epsabs: f64, epsrel: f64, limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qaws(f: *mut gsl_function, a: f64, b: f64,
                                t: *mut gsl_integration_qaws_table,
                                epsabs: f64, epsrel: f64, limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qawo(f: *mut gsl_function, a: f64, epsabs: f64,
                                epsrel: f64, limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                wf: *mut gsl_integration_qawo_table,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gsl_integration_qawf(f: *mut gsl_function, a: f64, epsabs: f64,
                                limit: usize,
                                workspace: *mut gsl_integration_workspace,
                                cycle_workspace:
                                    *mut gsl_integration_workspace,
                                wf: *mut gsl_integration_qawo_table,
                                result: *mut f64, abserr: *mut f64)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_integration_glfixed_table {
    pub n: usize,
    pub x: *mut f64,
    pub w: *mut f64,
    pub precomputed: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gsl_integration_glfixed_table() {
    assert_eq!(::std::mem::size_of::<gsl_integration_glfixed_table>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( gsl_integration_glfixed_table ) ));
    assert_eq! (::std::mem::align_of::<gsl_integration_glfixed_table>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( gsl_integration_glfixed_table
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_glfixed_table ) ) . n as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_glfixed_table ) , "::" , stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_glfixed_table ) ) . x as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_glfixed_table ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_glfixed_table ) ) . w as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_glfixed_table ) , "::" , stringify ! ( w ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_glfixed_table ) ) .
                precomputed as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_glfixed_table ) , "::" , stringify ! (
                precomputed ) ));
}
impl Clone for gsl_integration_glfixed_table {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gsl_integration_glfixed_table_alloc(n: usize)
     -> *mut gsl_integration_glfixed_table;
}
extern "C" {
    pub fn gsl_integration_glfixed_table_free(t:
                                                  *mut gsl_integration_glfixed_table);
}
extern "C" {
    pub fn gsl_integration_glfixed(f: *const gsl_function, a: f64, b: f64,
                                   t: *const gsl_integration_glfixed_table)
     -> f64;
}
extern "C" {
    pub fn gsl_integration_glfixed_point(a: f64, b: f64, i: usize,
                                         xi: *mut f64, wi: *mut f64,
                                         t:
                                             *const gsl_integration_glfixed_table)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct gsl_integration_cquad_ival {
    pub a: f64,
    pub b: f64,
    pub c: [f64; 64usize],
    pub fx: [f64; 33usize],
    pub igral: f64,
    pub err: f64,
    pub depth: ::std::os::raw::c_int,
    pub rdepth: ::std::os::raw::c_int,
    pub ndiv: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_gsl_integration_cquad_ival() {
    assert_eq!(::std::mem::size_of::<gsl_integration_cquad_ival>() , 824usize
               , concat ! (
               "Size of: " , stringify ! ( gsl_integration_cquad_ival ) ));
    assert_eq! (::std::mem::align_of::<gsl_integration_cquad_ival>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( gsl_integration_cquad_ival )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . a as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . b as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . c as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . fx as *
                const _ as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( fx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . igral as
                * const _ as usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( igral )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . err as *
                const _ as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . depth as
                * const _ as usize } , 808usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( depth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . rdepth
                as * const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( rdepth )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_ival ) ) . ndiv as
                * const _ as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_ival ) , "::" , stringify ! ( ndiv ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gsl_integration_cquad_workspace {
    pub size: usize,
    pub ivals: *mut gsl_integration_cquad_ival,
    pub heap: *mut usize,
}
#[test]
fn bindgen_test_layout_gsl_integration_cquad_workspace() {
    assert_eq!(::std::mem::size_of::<gsl_integration_cquad_workspace>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( gsl_integration_cquad_workspace )
               ));
    assert_eq! (::std::mem::align_of::<gsl_integration_cquad_workspace>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                gsl_integration_cquad_workspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_workspace ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_workspace ) , "::" , stringify ! ( size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_workspace ) ) .
                ivals as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_workspace ) , "::" , stringify ! ( ivals
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gsl_integration_cquad_workspace ) ) .
                heap as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                gsl_integration_cquad_workspace ) , "::" , stringify ! ( heap
                ) ));
}
impl Clone for gsl_integration_cquad_workspace {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn gsl_integration_cquad_workspace_alloc(n: usize)
     -> *mut gsl_integration_cquad_workspace;
}
extern "C" {
    pub fn gsl_integration_cquad_workspace_free(w:
                                                    *mut gsl_integration_cquad_workspace);
}
extern "C" {
    pub fn gsl_integration_cquad(f: *const gsl_function, a: f64, b: f64,
                                 epsabs: f64, epsrel: f64,
                                 ws: *mut gsl_integration_cquad_workspace,
                                 result: *mut f64, abserr: *mut f64,
                                 nevals: *mut usize) -> ::std::os::raw::c_int;
}
